#!/usr/bin/env python3
"""
Path Planning Method – θ-Binned Snake Strategy
==============================================

Reads best_spiral_cylindrical.csv (r_xy [radial distance m], phi_deg [rotation angle deg], z [height m], spiral)
and produces an ordered path output. Plots the path visually for inspection.

This planner generates a measurement path optimised for a robotic system
with three motion axes:
  • θ (rotation) – slowest axis
  • r (radial)  – fast linear axis
  • z (vertical) – fast linear axis

The goal is to minimise total rotational movement while using the faster
linear axes for most positioning.

Usage:
------------

Configured via:  config_capture.py

Run:
    python stage2_path_planner.py

Input:
    Reads coordinate CSV set in config_capture.py (usually "bbest_coordinates.csv" generated by 
    stage1_grid_gen.py
    
    CSV with columns:
      r_xy_mm, phi_deg, z_mm

Output:
    The script writes a coordinate CSV to file name set in config_capture.py 
    Coordinates are ordered for robotic motion with an added 'order_idx' column
    describing the visit sequence.

Code Pipeline Overview
----------------------

1) Load INPUT_CSV and validate required columns.
2) Convert geometry to meters for internal math; keep mm in DataFrame.
3) Classify points:
   – Compute z_min/z_max and mark top/bottom caps via CAP_TOL_MM.
   – Everything else is sidewall.
4) Bin by azimuth:
   – Build θ bins from phi_deg using DELTA_THETA_DEG.
5) Build visit order:
   – Sidewall per bin: sort by z; alternate up/down each bin (snake).
   – Caps per bin: sort by radius per CAP_RADIAL_ORDER.
   – Apply either CAP_ORDER mode: side_then_caps or interleave_caps.
   – Safety pass to append any missed indices.
6) Write OUTPUT_CSV with order_idx sorted by visit sequence.
7) Print summary (counts, θ bins) and render a 3D plot of the path.
"""

import pandas as pd  # DataFrame handling for CSV I/O and sorting
import numpy as np  # Numerical arrays and vectorised operations
import matplotlib.pyplot as plt  # Plotting for visualising the planned path
from mpl_toolkits.mplot3d import Axes3D  # noqa  # 3D plotting backend import (unused symbol but activates 3D)

from config_capture import (  # Import user-configured paths for I/O
INPUT_CSV,        # Path to the input CSV containing r_xy_mm, phi_deg, z_mm
OUTPUT_CSV,       # Path to the output CSV that will include order_idx
DELTA_THETA_DEG,  # θ-bin width (deg). Smaller → more bins, smoother θ progression.
CAP_TOL_MM, # Points within ±CAP_TOL_MM of min/max z are treated as caps (top/bottom).
SIDE_SNAKE_START, # Initial z traversal direction for sidewall bins: "up" or "down".
CAP_ORDER, # Handle all side bins first, then caps; or "interleave_caps".
CAP_RADIAL_ORDER, # For caps: sweep radially "inner_to_outer" or "outer_to_inner".
PRINT_SUMMARY # Whether to print counts and θ-bin info after writing the path
)


# ── Load data ────────────────────────────────────────────────────────────────
df = pd.read_csv(INPUT_CSV)  # Read the input coordinates into a DataFrame
required = {"r_xy_mm", "phi_deg", "z_mm"}  # Columns we require to proceed
if not required.issubset(df.columns):  # Validate the presence of required columns
    raise ValueError(f"Input must contain columns: {sorted(required)}")  # Fail early if columns missing

# Use meters internally for geometry/plotting; keep mm in DataFrame for I/O
r_xy_mm = df["r_xy_mm"].to_numpy(dtype=float)  # Extract r in mm as float array
phi_d   = df["phi_deg"].to_numpy(dtype=float) % 360.0  # Wrap φ to [0,360) degrees
z_mm    = df["z_mm"].to_numpy(dtype=float)  # Extract z in mm as float array

r_xy = r_xy_mm / 1000.0  # Convert r from mm to meters for geometry
z    = z_mm    / 1000.0  # Convert z from mm to meters for geometry
N    = len(df)  # Total number of points

# Cartesian for plotting
phi_rad = np.radians(phi_d)  # Convert φ from degrees to radians
x_all = r_xy * np.cos(phi_rad)  # X = r*cos(φ) for all points
y_all = r_xy * np.sin(phi_rad)  # Y = r*sin(φ) for all points

# Cap detection
z_min, z_max = float(z.min()), float(z.max())  # Determine min/max z to identify caps
cap_tol = CAP_TOL_MM / 1000.0  # Convert tolerance to meters
on_top_cap    = np.isclose(z, z_max, atol=cap_tol)  # Boolean mask: top cap points
on_bottom_cap = np.isclose(z, z_min, atol=cap_tol)  # Boolean mask: bottom cap points
on_cap        = on_top_cap | on_bottom_cap  # Mask for any cap point
on_side       = ~on_cap  # Mask for sidewall (non-cap) points

# θ-bins
bin_width = float(DELTA_THETA_DEG)  # Width of each θ bin in degrees
num_bins  = int(np.ceil(360.0 / bin_width))  # Number of bins to cover full 360°
theta_bins = np.floor(phi_d / bin_width).astype(int)  # Assign each point to a bin index
theta_bins = np.clip(theta_bins, 0, num_bins - 1)  # Clamp indices to valid range

# Helper: positive modular θ advance (deg)
def dphi_pos(a_deg, b_deg):  # Define helper to compute positive wrapped Δφ
    return (b_deg - a_deg) % 360.0  # Return Δφ in [0,360)

# ── Build order ──────────────────────────────────────────────────────────────
order_indices = []  # This list will store the visit order as indices into df

# Decide initial snake direction
snake_up = (SIDE_SNAKE_START.lower() == "up")  # True if starting by increasing z

# Pass 1: sidewall bins (z-snaking)
for b in range(num_bins):  # Iterate over all θ bins
    idxs = np.where((theta_bins == b) & on_side)[0]  # Get indices of sidewall points in this bin
    if idxs.size == 0:  # If no side points in this bin, skip
        continue  # Move to next bin

    # sort by z ascending
    z_sorted = idxs[np.argsort(z[idxs])]  # Sort bin’s side points by z (ascending)

    # alternate direction per bin to reduce deadhead on z
    if not snake_up:  # If current pass should go downward
        z_sorted = z_sorted[::-1]  # Reverse the order to descend in z

    order_indices.extend(z_sorted.tolist())  # Append this bin’s ordered indices
    snake_up = not snake_up  # Alternate the snake direction for the next bin

# Pass 2: caps per bin (short radial spokes)
def append_caps_for_bin(bin_idx):  # Helper to append cap points for a given bin
    # Top cap
    top = np.where((theta_bins == bin_idx) & on_top_cap)[0]  # Indices of top-cap points in this bin
    if top.size:  # If any top-cap points exist
        if CAP_RADIAL_ORDER == "inner_to_outer":  # Decide radial sweep direction
            top_sorted = top[np.argsort(r_xy[top])]  # Sort by radius (inner→outer)
        else:
            top_sorted = top[np.argsort(r_xy[top])[::-1]]  # Sort outer→inner
        order_indices.extend(top_sorted.tolist())  # Append ordered top-cap points

    # Bottom cap
    bot = np.where((theta_bins == bin_idx) & on_bottom_cap)[0]  # Indices of bottom-cap points in this bin
    if bot.size:  # If any bottom-cap points exist
        if CAP_RADIAL_ORDER == "inner_to_outer":  # Decide radial sweep direction
            bot_sorted = bot[np.argsort(r_xy[bot])]  # Sort by radius (inner→outer)
        else:
            bot_sorted = bot[np.argsort(r_xy[bot])[::-1]]  # Sort outer→inner
        order_indices.extend(bot_sorted.tolist())  # Append ordered bottom-cap points

if CAP_ORDER == "side_then_caps":  # If we process all side bins first, then caps
    for b in range(num_bins):  # For each θ bin
        append_caps_for_bin(b)  # Append its cap points after the sidewall pass
elif CAP_ORDER == "interleave_caps":  # Alternatively interleave caps with each side bin
    # Simple interleave: after each side bin, do its caps immediately
    order_indices_interleaved = []  # Temporary list when interleaving
    snake_up = (SIDE_SNAKE_START.lower() == "up")  # Reset snake direction for interleaving
    for b in range(num_bins):  # Iterate bins
        # side for bin b
        idxs = np.where((theta_bins == b) & on_side)[0]  # Sidewall points in bin b
        if idxs.size:  # If any sidewall points
            z_sorted = idxs[np.argsort(z[idxs])]  # Sort by z (ascending)
            if not snake_up:  # Reverse if current direction is descending
                z_sorted = z_sorted[::-1]
            order_indices_interleaved.extend(z_sorted.tolist())  # Append side points
            snake_up = not snake_up  # Flip direction

        # caps for bin b
        # reuse helper but append into interleaved list
        top = np.where((theta_bins == b) & on_top_cap)[0]  # Top-cap points in bin b
        if top.size:  # If any top-cap points
            if CAP_RADIAL_ORDER == "inner_to_outer":  # Decide radial ordering
                top_sorted = top[np.argsort(r_xy[top])]
            else:
                top_sorted = top[np.argsort(r_xy[top])[::-1]]
            order_indices_interleaved.extend(top_sorted.tolist())  # Append top-cap points

        bot = np.where((theta_bins == b) & on_bottom_cap)[0]  # Bottom-cap points in bin b
        if bot.size:  # If any bottom-cap points
            if CAP_RADIAL_ORDER == "inner_to_outer":  # Decide radial ordering
                bot_sorted = bot[np.argsort(r_xy[bot])]
            else:
                bot_sorted = bot[np.argsort(r_xy[bot])[::-1]]
            order_indices_interleaved.extend(bot_sorted.tolist())  # Append bottom-cap points

    order_indices = order_indices_interleaved  # Use the interleaved order

# Safety: ensure all points included exactly once
seen = set(order_indices)  # Create a set of indices we’ve included
if len(seen) != N:  # If count mismatches total points, we have duplicates or misses
    # If any missing or duplicates, rebuild by appending any missing at the end
    missing = [i for i in range(N) if i not in seen]  # Find indices that were not included
    # (Should be empty; if not, append in ascending φ then z.)
    if missing:  # Only act if we truly missed some points
        m = np.array(missing)  # Convert list to array for vectorised sorting
        m_sorted = m[np.lexsort((z[m], phi_d[m]))]  # Sort by φ then z as a fallback order
        order_indices.extend(m_sorted.tolist())  # Append the missing points at the end

# ── Build output dataframe with order only (no rotation stats) ───────────────
out = df.copy()  # Duplicate the original DataFrame to preserve original columns
out["order_idx"] = -1  # Initialise order column to -1 (placeholder)
out.loc[order_indices, "order_idx"] = np.arange(N)  # Fill order_idx in visit sequence

# Sort by visit order and save (keeps mm columns in output)
out = out.sort_values("order_idx").reset_index(drop=True)  # Sort by order and reset index
out.to_csv(OUTPUT_CSV, index=False)  # Write the ordered plan to disk

if PRINT_SUMMARY:  # Optional summary print-out
#    total_rot = float(step_rot.sum())  # (Placeholder for rotation stats; not computed)
#    max_step  = float(step_rot[1:].max()) if N > 1 else 0.0  # (Placeholder)
    side_count = int(on_side.sum())  # Count sidewall points
    top_count  = int(on_top_cap.sum())  # Count top-cap points
    bot_count  = int(on_bottom_cap.sum())  # Count bottom-cap points
    print(f"Saved {OUTPUT_CSV}")  # Confirm the save location
    print(f"Points: {N} (side {side_count}, top {top_count}, bottom {bot_count})")  # Composition summary
#    print(f"Total positive rotation: {total_rot:.1f} deg | Max step: {max_step:.1f} deg")  # (Placeholder)
    print(f"θ bins: {num_bins} @ {DELTA_THETA_DEG:.2f} deg")  # Bin configuration summary

# ── Plot ordered path in 3D ─────────────────────────────────────────────────
# Rebuild ordered Cartesian for the path (convert mm → m for plotting)
phi_order_rad = np.radians(out["phi_deg"].to_numpy())  # φ (rad) for ordered rows
x_order = (out["r_xy_mm"].to_numpy(dtype=float) / 1000.0) * np.cos(phi_order_rad)  # X coords of ordered path
y_order = (out["r_xy_mm"].to_numpy(dtype=float) / 1000.0) * np.sin(phi_order_rad)  # Y coords of ordered path
z_order = (out["z_mm"].to_numpy(dtype=float) / 1000.0)  # Z coords of ordered path

fig = plt.figure(figsize=(9, 7))  # Create a figure for 3D plot
ax = fig.add_subplot(111, projection="3d")  # Add a 3D subplot

# All points (light gray)
ax.scatter(x_all, y_all, z, c="lightgray", s=10, alpha=0.35, label="All points")  # Scatter all points for context

# Ordered path (red line)
ax.plot(x_order, y_order, z_order, c="red", linewidth=1.6, label="Plan #1 path")  # Plot the planned path as a line

# Start / End markers
ax.scatter(x_order[0], y_order[0], z_order[0], c="green", s=60, label="Start")  # Mark the start point
ax.scatter(x_order[-1], y_order[-1], z_order[-1], c="blue", s=60, label="End")  # Mark the end point

# Ensure equal axis scaling for correct perspective
max_range = np.array([  # Compute span of each axis
    x_all.max() - x_all.min(),
    y_all.max() - y_all.min(),
    z.max()     - z.min()
]).max() / 2.0  # Use half of the largest span to set symmetric limits
mid_x = (x_all.max() + x_all.min()) * 0.5  # Midpoint of X
mid_y = (y_all.max() + y_all.min()) * 0.5  # Midpoint of Y
mid_z = (z.max()     + z.min()) * 0.5  # Midpoint of Z
ax.set_xlim(mid_x - max_range, mid_x + max_range)  # X limits for equal scaling
ax.set_ylim(mid_y - max_range, mid_y + max_range)  # Y limits for equal scaling
ax.set_zlim(mid_z - max_range, mid_z + max_range)  # Z limits for equal scaling

# Labels & look
ax.set_xlabel("X (m)")  # X-axis label
ax.set_ylabel("Y (m)")  # Y-axis label
ax.set_zlabel("Z (m)")  # Z-axis label
ax.set_title(f"Plan #1: θ-binned snake (Δθ={DELTA_THETA_DEG}°, cap tol={CAP_TOL_MM} mm)")  # Plot title
ax.legend()  # Show legend
plt.tight_layout()  # Nicely fit plot into the figure canvas
plt.show()  # Display the 3D plot window

r"""
       ____  __  __ ___ _____ ______   __   
      |  _ \|  \/  |_ _|_   _|  _ \ \ / /   
      | | | | |\/| || |  | | | |_) \ V /    
      | |_| | |  | || |  | | |  _ < | |     
     _|____/|_| _|_|___| |_| |_|_\_\|_|   __
    |  ___/ \  |  _ \_ _| \ | |/ _ \ \   / /
    | |_ / _ \ | |_) | ||  \| | | | \ \ / / 
    |  _/ ___ \|  __/| || |\  | |_| |\ V /  
    |_|/_/   \_\_|  |___|_| \_|\___/  \_/   
                       
                     ███                 
                   █████         ███     
                 ███████         ████    
               █████████    ██    ████   
     ███████████████████    ████   ████  
    ████████████████████     ███   ████  
    ████████████████████      ██    ████ 
    ████████████████████      ███    ████ 
    ████████████████████      ███    ████ 
    ████████████████████     ███    ████  
     ███████████████████    ████   ████  
              ██████████    ███   ████   
                ████████    █    ████    
                  ██████         ███     
                     ███    
"""